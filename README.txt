Project Description
By looking at the code for my project, you can see I divided it into two seperate files, ‘tcp_server.c’ & ‘tcp_client.c’. When compiling the files, you will need to use the ‘-o’ flag to specify the name of the executable. When the executable for ‘tcp_server.c’ is run, the terminal prints “%d more clients may connect. Listening for new clients...”. Now that the server is listening for incoming connections, you can then run the client executable from another terminal. If the connection was successful, the server will print that a new client has connected and will tell you how many more clients may connect. It will also send a message to all connected clients that a new connection has entered the server. Once multiple clients are connected, clients are able to send and receive messages to and from other connected clients.
When a client is ready to leave the server, they can either type ‘leave’, ctrl C the program, or exit out of the terminal. In any case, the other clients will be aware what client has disconnected, and the server will update to reflect how many more clients can join. If an error occurs, it should print to the appropriate program.

Detailed Design
To begin this project, I first had to research how sockets work and how they can be implemented into C. Once I had a better understanding on what header files to include and how to create and bind a socket to a specified IP and port, I began writing my server program. In order to handle multiple clients, I chose to use the function ‘select()’. I learned that there were other alternatives such as ‘forking’ or ‘threading’, but seeing how this is my first time working with sockets, I wanted to keep it simple. Select is a blocking system call, meaning the program will only execute further if data arrives on any of the polled sockets. To determine what those sockets are, you must use the structure ‘fd_set’ along with the accompanying macros of ‘FD_ZERO’, ‘FD_SET’, ‘FD_ISSET’ and ‘FD_CLR’ to add sockets (or file descriptors) to a set. This is why a for loop is used, because we need to look at every socket in the set. Because calling select destroys the set of sockets, a temporary one must be created at the beginning of the while loop. Select will only return when some activity occurs, so following the select call are conditions to check if a client is trying to connect to the listening socket or trying to send data to other clients. In the case that a client is trying to connect to the listening socket, we first check if the socket is part of the set. If it is, we then see if it shares the same file descriptor as the listening socket. If this is the case, then we know that we are trying to connect, so we do so and add the new client to the set. In the case that the client is sending data, the ‘recv’ function is used. If recv returns zero or less, then we know the client either disconnected (equals 0) or there was an error. In either case, we want to close that socket and clear it from the set. Recv otherwise returns the number of bytes received, so we once again loop through the set of our sockets and send the received bytes to other clients.
The client is similar to the server, but connects instead of listens. In the client, I actually added ‘0’ to the set so that the program could watch for input. Because zero is in the set, the client will stop on the ‘fgets()’ line and wait for user input. If the client isn’t sending messages, then they are receiving them. This is documented more clearly in the code.
